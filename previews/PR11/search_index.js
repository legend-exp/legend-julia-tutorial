var documenterSearchIndex = {"docs":
[{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/legend-exp/legend-julia-tutorial/blob/main/legend-julia-software-tutorial.jl\"","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial is licensed under the MIT License (MIT).","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"# Load required Julia packages:\n\nusing Plots\n\nusing ArraysOfArrays, StaticArrays, Tables, TypedTables\nusing Statistics, Random, Distributions, StatsBase\nusing Unitful\nimport HDF5\n\nusing SolidStateDetectors\nusing RadiationSpectra\nusing RadiationDetectorSignals\nusing RadiationDetectorSignals: group_by_evtno, ungroup_by_evtno, group_by_evtno_and_detno\nusing LegendDataTypes\nusing LegendHDF5IO: readdata, writedata\nusing LegendTextIO","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"<h1 style=\"text-align: center\">     LEGEND Software Stack Tutorial in <br/>     <img alt=\"Julia\" src=\"images/logos/julia-logo.svg\" style=\"height: 4em; display: inline-block; margin: 1em;\"/>     <img alt=\"Julia\" src=\"images/logos/ssd_logo.svg\" style=\"height: 4em; display: inline-block; margin: 1em;\"/> </h1>","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"<p style=\"text-align: center\">     Felix&nbsp;Hagemann&nbsp;&lang;<a href=\"mailto:hagemann@mpp.mpg.de\" target=\"blank\">hagemann@mpp.mpg.de</a>&rang;,     Lukas&nbsp;Hauertmann&nbsp;&lang;<a href=\"mailto:lhauert@mpp.mpg.de\" target=\"blank\">lhauert@mpp.mpg.de</a>&rang;,     David&nbsp;Hervas&nbsp;Aguilar&nbsp;&lang;<a href=\"mailto:hervasa2@mpp.mpg.de\" target=\"blank\">hervasa2@mpp.mpg.de</a>&rang;,     Oliver&nbsp;Schulz&nbsp;&lang;<a href=\"mailto:oschulz@mpp.mpg.de\" target=\"blank\">oschulz@mpp.mpg.de</a>&rang;,     Martin&nbsp;Schuster&nbsp;&lang;<a href=\"mailto:schuster@mpp.mpg.de\" target=\"blank\">schuster@mpp.mpg.de</a>&rang;,     Anna&nbsp;Julia&nbsp;Zsigmond&nbsp;&lang;<a href=\"azsigmon@mpp.mpg.de\" target=\"blank\">azsigmon@mpp.mpg.de</a>&rang; </p>","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"<p style=\"text-align: center\">     SolidStateDetectors.jl (SSD)<br>     <a href=\"https://juliaphysics.github.io/SolidStateDetectors.jl/stable/\" target=\"blank\">Documentation</a><br>     <a href=\"https://github.com/JuliaPhysics/SolidStateDetectors.jl\" target=\"blank\">GitHub</a><br>     <a href=\"https://iopscience.iop.org/article/10.1088/1748-0221/16/08/P08007\" target=\"_blank\">Paper</a> </p> <div style=\"margin-top:0.0em\">     <p style=\"text-align: center\">         <img alt=\"LEGEND Logo\" src=\"images/logos/legend-logo.svg\" style=\"height: 20em; display: inline-block; margin: 0em;\"/>     </p> </div>","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"<p>See <a href=\"README.md\">README.md</a> for instructions.</p>","category":"page"},{"location":"legend-julia-software-tutorial/#Calculation-of-detector-potentials-and-fields","page":"Tutorial","title":"Calculation of detector potentials and fields","text":"","category":"section"},{"location":"legend-julia-software-tutorial/#Detector-definition","page":"Tutorial","title":"Detector definition","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"First, load a detector definition - here, an inverted-coaxial example detector design:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"detector_config_filename = SSD_examples[:InvertedCoax]\nT = Float32 # Optional; Default is Float32, but works with Float64 as well\nsim = Simulation{T}(detector_config_filename)\nplot(sim.detector, size = (700, 700))","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also have a look at how the initial conditions look like on the grid (it starts with a very coarse grid):","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"This is optional. Its only to have a look at the initial state. For example, if you want to check if you specified the detector geometry correctly in your configuration file.","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"apply_initial_state!(sim, ElectricPotential)\nplot(\n    plot(sim.electric_potential), # initial electric potential (boundary conditions)\n    plot(sim.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(sim.q_eff_imp), # effective charge density distribution\n    plot(sim.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, calculate the electric potential:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_potential!(sim, convergence_limit = 1e-6, refinement_limits = [0.2, 0.1, 0.05, 0.01])","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    plot(sim.electric_potential, φ = 20), # initial electric potential (boundary conditions)\n    plot(sim.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(sim.q_eff_imp), # effective charge density distribution\n    plot(sim.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"get_active_volume(sim.point_types) # approximation (sum of the volume of cells marked as depleted)","category":"page"},{"location":"legend-julia-software-tutorial/#Partially-depleted-detectors","page":"Tutorial","title":"Partially depleted detectors","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"sim_undep = deepcopy(sim)\nsim_undep.detector = SolidStateDetector(sim_undep.detector, contact_id = 2, contact_potential = 500); # V  <-- Bias Voltage of Mantle\n\ncalculate_electric_potential!( sim_undep,\n                               depletion_handling = true,\n                               convergence_limit = 1e-6,\n                               refinement_limits = [0.2, 0.1, 0.05, 0.03],\n                               verbose = false)\n\nplot(\n    plot(sim_undep.electric_potential),\n    plot(sim_undep.point_types),\n    layout = (1, 2), size = (800, 700)\n)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"Depleted:   \", get_active_volume(sim.point_types))\nprintln(\"Undepleted: \", get_active_volume(sim_undep.point_types));\nnothing #hide","category":"page"},{"location":"legend-julia-software-tutorial/#Electric-field-calculation","page":"Tutorial","title":"Electric field calculation","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Calculate the electric field of the fully depleted detector, given the already calculated electric potential:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_field!(sim, n_points_in_φ = 72)\ncalculate_electric_field!(sim_undep, n_points_in_φ = 72)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sim.electric_field, full_det = true, φ = 0.0, size = (700, 700))\nplot_electric_fieldlines!(sim, full_det = true, φ = 0.0)","category":"page"},{"location":"legend-julia-software-tutorial/#Weighting-potential-calculation","page":"Tutorial","title":"Weighting potential calculation","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"We need weighting potentials to simulate the detector charge signal induced by drifting charges. We'll calculate the weighting potential for the point contact and the outer shell of the detector:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"for contact in sim.detector.contacts\n    calculate_weighting_potential!(sim, contact.id, refinement_limits = [0.2, 0.1, 0.05, 0.01], n_points_in_φ = 2, verbose = false)\nend","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    plot(sim.weighting_potentials[1]),\n    plot(sim.weighting_potentials[2]),\n    size = (900, 700)\n)","category":"page"},{"location":"legend-julia-software-tutorial/#Detector-capacitance","page":"Tutorial","title":"Detector capacitance","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"After the weighting potentials are calculated, one can determine the detector capacitance matrix:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_capacitance_matrix(sim)","category":"page"},{"location":"legend-julia-software-tutorial/#Drift-and-waveform-simulation","page":"Tutorial","title":"Drift and waveform simulation","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Given the electric field and a charge drift model, the charge drift can be simulated:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"charge_drift_model = ADLChargeDriftModel()\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model);\nnothing #hide","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, let's create an \"random\" (multisite) event:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"starting_positions = [ CylindricalPoint{T}( 0.020, deg2rad(10), 0.015 ),\n                       CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ),\n                       CylindricalPoint{T}( 0.022, deg2rad(35), 0.025 ) ]\nenergy_depos = T[1460, 609, 1000] * u\"keV\" # are needed later in the signal generation\n\nevt = Event(starting_positions, energy_depos);\nnothing #hide","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"simulate!(evt, sim, Δt = 5u\"ns\")","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sim.detector, size = (700, 700))\nplot!(evt.drift_paths)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"p_pc_signal = plot( evt.waveforms[1], lw = 1.5, xlims = (0, 1000), xlabel = \"Time\", ylabel = \"Charge\",\n                    unitformat = :slash, legend = false, tickfontsize = 12, guidefontsize = 14)","category":"page"},{"location":"legend-julia-software-tutorial/#I/O","page":"Tutorial","title":"I/O","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"The package offers a conversion of all the calculated fields to NamedTuples which allows for saving and loading them into HDF5 files via the LegendHDF5IO.jl package:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"sim","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"filename = \"cache/inverted_coax_simulation.h5f\"\nif !ispath(dirname(filename)) mkpath(dirname(filename)) end\nssd_write(filename, sim)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"sim = ssd_read(filename, Simulation);\nnothing #hide","category":"page"},{"location":"legend-julia-software-tutorial/#Quick-simulation","page":"Tutorial","title":"Quick simulation","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"All the above steps, which offer more fine control over the individual steps, can be done with one function, simulate!. This can be useful if one just want to quickly test the config file for a new detector.","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"quick_sim = Simulation{T}(detector_config_filename)\nsimulate!(quick_sim);\nplot(\n    plot(quick_sim.electric_potential),\n    plot(quick_sim.weighting_potentials[1]),\n    plot(quick_sim.weighting_potentials[2]),\n    size = (1200, 500), layout = (1, 3)\n)","category":"page"},{"location":"legend-julia-software-tutorial/#Waveform-generation-for-Geant4-MC-events","page":"Tutorial","title":"Waveform generation for Geant4 MC events","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's read in some Monte-Carlo events (produced by Geant4). We'll either read from Geant4 CSV and cache the result as HDF5, or read directly from HDF5 if already available:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"mctruth_filename_csv = joinpath(\"data\", \"dual-invcoax-mctruth.csv\")\nmctruth_filename_hdf5 = joinpath(\"cache\", \"dual-invcoax-mctruth.h5\")\nif isfile(mctruth_filename_hdf5)\n    println(\"Reading MC events from HDF5.\")\n    mc_events = HDF5.h5open(mctruth_filename_hdf5, \"r\") do input\n        readdata(input, \"mctruth\")\n    end\nelse\n    println(\"Reading MC events from Geant4-CSV.\")\n    mc_events = open(read, mctruth_filename_csv, Geant4CSVInput)\n    mkpath(dirname(mctruth_filename_hdf5))\n    println(\"Writing MC events to HDF5.\")\n    HDF5.h5open(mctruth_filename_hdf5, \"w\") do output\n        writedata(output, \"mctruth\", mc_events)\n    end\nend","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Producing pulse shapes from raw MC events is wasteful, it's more efficient to cluster detectors hits (within a small radius) first:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"$(sum(length.(mc_events.edep))) hits before clustering\")\nmc_events_clustered = @time SolidStateDetectors.cluster_detector_hits(mc_events, 0.2u\"mm\")\nprintln(\"$(sum(length.(mc_events_clustered.edep))) hits after clustering\")","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Table of MC events is of type DetectorHitEvents:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"typeof(mc_events_clustered) <: DetectorHitEvents","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"We have a plotting recipe for DetectorHitEvents:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(mc_events_clustered)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Waveform generation has to be per detector. Let's reshuffle the detector hits, grouping by event number and detector:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"hits = ungroup_by_evtno(mc_events_clustered)\nmc_events_per_det = group_by_evtno_and_detno(hits)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"The hits are now grouped by event number, but separately for each detector, and sorted by detector number:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"issorted(mc_events_per_det.detno)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"This makes it easy to group them by detector number ...","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"mc_events_by_det = Table(consgroupedview(mc_events_per_det.detno, Tables.columns(mc_events_per_det)))","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"... and get all events for detector 1 in one chunk:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"mc_events_det1 = Table(mc_events_by_det[1])","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(mc_events_det1)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Raw MC events have a very narrow line width:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"stephist(ustrip.(sum.(mc_events_det1.edep)), bins = 2600:0.1:2625, yscale = :log10)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's make things more realistic by adding Fano noise:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Random.seed!(123) # only for testing\ndet_material = sim.detector.semiconductor.material\nmc_events_fnoise = add_fano_noise(mc_events_det1, det_material.E_ionisation, det_material.f_fano)\nstephist(ustrip.(sum.(mc_events_det1.edep)), bins = 2600:0.1:2625, label = \"raw MC edep\", yscale = :log10)\nstephist!(ustrip.(sum.(mc_events_fnoise.edep)), bins = 2600:0.1:2625, label = \"with Fano noise\", yscale = :log10)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Also, we need to filter out the few events that, due to numerical effects, lie outside of the detector (the proper solution is to shift them slightly, this feature will be added in the future):","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"filtered_events = mc_events_fnoise[findall(pts -> all(p -> CartesianPoint(T.(ustrip.(uconvert.(u\"m\", p)))) in sim.detector, pts), mc_events_fnoise.pos)];\nlength(filtered_events)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"contact_charge_signals = simulate_waveforms(\n        filtered_events[1:2000],\n        sim,\n        max_nsteps = 4000,\n        Δt = 1u\"ns\",\n        verbose = false);\nnothing #hide","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's plot the first 100 generated waveforms:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"waveforms = ArrayOfRDWaveforms(contact_charge_signals.waveform)\nplot(waveforms[1:100], legend = false)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also look individual events","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"evt1 = Event(filtered_events[1], T)\nsimulate!(evt1, sim, max_nsteps = 4000, Δt = 1u\"ns\", verbose = true)\np_drift = plot(sim.detector, label = \"\")\nplot!(evt1.drift_paths)\np_signal = plot(evt1.waveforms[1], lw = 2, legend = false)\nplot(p_drift, p_signal, size = (800, 400))","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"We should add pre- and post-pulse baselines ...","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"waveforms_with_baseline_and_tail = ArrayOfRDWaveforms(SolidStateDetectors.add_baseline_and_extend_tail.(waveforms, 1200, 7000));\nplot(waveforms_with_baseline_and_tail[1:10], legend = false)","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"... and also add some random values along the waveforms to simulate electronics noise in a simple fashion:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"noisy_waveforms = ArrayOfRDWaveforms(\n    map(\n        wf -> RDWaveform(wf.time, wf.signal .+ rand!(Normal(0, 5e3), similar(ustrip.(wf.signal)))*unit(eltype(wf.signal))),\n        waveforms_with_baseline_and_tail\n    )\n);\nnothing #hide","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(noisy_waveforms[1:100], legend = false, size = (900, 400))","category":"page"},{"location":"legend-julia-software-tutorial/#Waveform-DSP","page":"Tutorial","title":"Waveform DSP","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"Note: This section only demonstrates a very simple form of DSP for energy reconstruction, and will be extended in the near future.","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"We can reconstruct a spectrum from the simulated waveforms, using the difference between the pre- and post-pulse baseline means as energy of the events (equivalent to a triangular shaping filter in a fixed position):","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"filter_length = 50\npre_pulse_mean = mean.(map(signal -> signal[1:filter_length], noisy_waveforms.signal))\npre_pulse_std = std.(map(signal -> signal[1:filter_length], noisy_waveforms.signal))\nenergy_threshold = mean(pre_pulse_std) * 3\npost_pulse_mean = mean.(map(signal -> signal[end-filter_length:end], noisy_waveforms.signal))\nE_reco = post_pulse_mean .- pre_pulse_mean\nhist_uncal = fit(Histogram, ustrip.(filter(e -> e > energy_threshold, E_reco)), nbins = 1000)\nplot(hist_uncal, st = :step, yscale = :log10, label=\"uncalibrated spectrum\")","category":"page"},{"location":"legend-julia-software-tutorial/#Spectrum-analysis","page":"Tutorial","title":"Spectrum analysis","text":"","category":"section"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"The package RadiationSpectra.jl provides a mechanism finding peaks in the spectrum. It can also run an auto-calibration of the spectrum, given a list of gamma lines that may be in the spectrum:","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"gamma_lines = [510.77, 583.191, 727.330, 860.564, 2614.533]\n\nh_cal, h_deconv, peakPositions, threshold, c, c_precal = RadiationSpectra.calibrate_spectrum(\n    hist_uncal, gamma_lines)\n\np_uncal = plot(hist_uncal, st=:step, label = \"uncalibrated spectrum\", tickfontsize = 12, legendfontsize = 12)\np_deconv = plot(h_deconv, st=:step, label = \"deconvolved spectrum\", tickfontsize = 12, legendfontsize = 12)\nhline!([threshold], label =\"threshold\")\np_cal = plot(h_cal, st = :step, yscale = :log10, label=\"calibrated spectrum\", xlabel=\"E / keV\", xlims=[0, 3000], xticks=0:500:3000, tickfontsize = 12, legendfontsize = 12, guidefontsize = 14)\nvline!(gamma_lines, label=\"gamma lines: $(gamma_lines)\")\nplot(p_uncal, p_deconv, p_cal, layout = (3,1), size = (1000, 700))","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"legend-julia-software-tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\r\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LEGEND-Julia-Software-Stack-Tutorial","page":"LEGEND Julia Software Stack Tutorial","title":"LEGEND Julia Software Stack Tutorial","text":"","category":"section"},{"location":"","page":"LEGEND Julia Software Stack Tutorial","title":"LEGEND Julia Software Stack Tutorial","text":"This tutorial demonstrates the LEGEND Julia software stack: It shows how to simulate an inverted-coaxial HPGe detector, how to generate detector waveforms based on Geant4 MC results, how to reconstruct an energy spectrum from the simulated pulses and how to perform an auto-calibration of the resulting spectrum.","category":"page"}]
}
